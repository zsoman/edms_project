#!/usr/bin/env python
"""Managing of user data

The data of the users are stored in the users directory (by default).

The file names are the identifiers of the users.

A new user identifier is generated by finding the maximal value of the identifiers and increasing by one.

The fields of a user object stored in the text file line-by-line as:

    first_name
    family_name
    birth
    email
    password

"""

# Imports -----------------------------------------------------------------------------------------------------------
import logging
import xml.etree.ElementTree as ET
from collections import Counter
from datetime import datetime, date
from json import load, dump
from os import path, remove, listdir
from re import match
from shutil import move

import storage_utils
from iniformat.reader import read_ini_file

# Authorship information  -------------------------------------------------------------------------------------------
__author__ = "Zsolt Bokor Levente"
__copyright__ = "Copyright 2016, Morgan Stanley - Training 360 Project"
__credits__ = __author__
__version__ = "1.0.0"
__maintainer__ = __author__
__email__ = ["bokor.zsolt5@gmail.com", "bokorzsolt@yahoo.com"]
__status__ = "Development"

# Parameters --------------------------------------------------------------------------------------------------------

DELIMITER_CHAR = ':'
ROLE_DELIMITER_CHAR = ','
module_logger = logging.getLogger('repository.users')


# -------------------------------------------------------------------------------------------------------------------

class UserNotFoundError(Exception):
    """
    This exception is raised when a :py:class:User object is not found.
    """
    pass


class WrongFileTypeError(Exception):
    """
    This exception is raised when a file's type is not correct.
    """
    pass


class MissingUserIdentifierError(Exception):
    """
    This exception is raised when a :py:class:User object ID is missing.
    """
    pass


class MissingDelimiterCharacterError(Exception):
    """
    This exception is raised when a the :py:const:DELIMITER_CHAR or the :py:const:ROLE_CELIMITER_CHAR is missing from
    the :py:class:User object's roles file.
    """
    pass


class InvalidRoleNameError(Exception):
    """
    This exception is raised when a :py:class:Role object's :py:attr:name is wrong.
    """
    pass


class InconsistentUseOfRoleDelimiterError(Exception):
    """
    This exception is raised when a the :py:const:DELIMITER_CHAR or the :py:const:ROLE_CELIMITER_CHAR is missing from
    the :py:class:User object's roles file.
    """
    pass


class DuplicateUserIdentifierError(Exception):
    """
    This exception is raised when a :py:class:User object's ID is duplicated in the users file.
    """
    pass


class DuplicatedRolesError(Exception):
    """
    This exception is raised when a :py:class:Role object is duplicated in the roles file.
    """
    pass


class User(object):
    """User of the document repository.

    The :py:class:User object is defined by: first name, family name, birth date, email address and a password.
    """

    def __init__(self, first_name, family_name, birth, email, password):
        """
        Initialisation of a new :py:class:User object.

        :param first_name: The :py:class:User object's first name.
        :param family_name: The :py:class:User object's family name
        :param birth: The :py:class:User object's birth date.
        :param email: The :py:class:User object's email address.
        :param password: The :py:class:User object's password.
        """
        if User.is_valid_name(first_name):
            self._first_name = first_name
        else:
            raise TypeError("The {} first name is not a valid name!".format(first_name))

        if User.is_valid_name(family_name):
            self._family_name = family_name
        else:
            raise TypeError("The {} family name is not a valid name!".format(family_name))

        if User.is_valid_date(birth):
            self._birth = birth
        else:
            raise TypeError("The {} birt date is not a valid date!".format(birth))

        if User.is_valid_email(email):
            self._email = email
        else:
            raise ValueError(
                "The {} email address is not a valid email address!".format(email))

        if User.is_valid_password(password):
            self._password = password
        else:
            raise TypeError("The {} password is not a valid string!".format(password))

    @classmethod
    def is_valid_name(cls, name):
        """
        Determines if the ``name`` is valid.
        :param name: String.
        :return: Bool, TRUE if the ``name`` is alphanumerical.
        """
        return name.isalnum()

    @classmethod
    def is_valid_date(cls, date_obj):
        """
        Determines if the ``date_obj`` is a valid date, is instance of date.

        :param date_obj: Date object.
        :return: Bool, TRUE if ``date_obj`` is instance of date.
        """
        return isinstance(date_obj, date)

    @classmethod
    def is_valid_email(cls, email):
        """
        Determines if the ``email`` is a valid email address.

        :param email: String email address.
        :return: Bool, TRUE if the regex mathes the ``email``.
        """
        return match('^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,4})$', email)

    @classmethod
    def is_valid_password(cls, password):
        """
        Determines if the ``password`` is a valid password.

        :param password: String, password.
        :return: Bool, TRUE if the ``password`` is instanceo of string.
        """
        for char in password:
            if not isinstance(char, str):
                return False
        return True

    @property
    def first_name(self):
        """
        The property of the :py:attr:_first_name attribute.

        :return: The first_name of the :py:class:User object :py:attr:_first_name.
        """
        return self._first_name

    @property
    def family_name(self):
        """
        The property of the :py:attr:_family_name attribute.

        :return: The family_name of the :py:class:User object :py:attr:_family_name.
        """
        return self._family_name

    @property
    def full_name(self):
        """
        The property of the :py:attr:_first_name and :py:attr:_family_name attributes concatanation.

        :return: The full_name of the :py:class:User object.
        """
        return self._first_name + ' ' + self._family_name

    @property
    def birth(self):
        """
        The property of the :py:attr:_birth attribute.

        :return: The birth of the :py:class:User object :py:attr:_birth.
        """
        return self._birth

    @property
    def email(self):
        """
        The property of the :py:attr:_first_email attribute.

        :return: The email of the :py:class:User object :py:attr:_first_email.
        """
        return self._email

    @property
    def password(self):
        """
        The property of the :py:attr:_password attribute.

        :return: The password of the :py:class:User object :py:attr:_password.
        """
        return self._password

    def __str__(self):
        """
        String representation of the :py:class:User.

        :return: :py:class:User represented by a string in the following format: :py:attr:full_name :py:attr:birth
        :py:attr:email :py:attr:password.
        """
        return '{} {} {} {}'.format(self.full_name, self.birth, self.email, self.password)


class Role(object):
    """Represents the roles of the users.

    The :py:class:Role is defined by a :py:attr:role string attribute.
    """

    def __init__(self, role):
        """
        Initialisation of a new :py:class:Role object.

        :param role: The :py:class:Role object's name.
        :exception ValueError is raised if the ``role`` is not valid.
        """
        if role in ['admin', 'manager', 'author', 'reviewer', 'visitor', '']:
            self._role = role
        else:
            raise ValueError("The '{}' is an invalid role!".format(role))

    @property
    def role(self):
        """
        The property of the :py:attr:_role attribute.

        :return: The role of the :py:class:Role object :py:attr:_role.
        """
        return self._role

    def __eq__(self, other):
        """
        Two :py:class:Role objects are equal when the :py:attr:role attributes of the objects are equal.

        :param other: The other :py:clss:Role object.
        :return: Bool, TRUE if the two :py:attr:role attributes are equal.
        """
        if isinstance(other, self.__class__):
            return self._role == other._role
        return False

    def __str__(self):
        """
        The string representation of the :py:class:Role object is the :py:attr:role attribute.
        :return: The :py:attr:role attribute of the object.
        """
        return self._role


class RoleManager(object):
    """Manage the user roles which are stored in a text file.

    The :py:class:RoleManager is defined by a :py:attr:_location path attribute. This equals to the :py:class:Repository
    object's users directory.
    """

    def __init__(self, repository_location, paths_file):
        """
        Initialisation of a new :py:class:RoleManager object.

        :param repository_location: The path of the users directory linked to the :py:class:Repository object.
        :param paths_file: Tbe paths file path of the :py:class:Repository object.
        """
        metadata_data = read_ini_file(paths_file)
        self._location = path.join(repository_location, metadata_data['directories']['users'])

    def read_roles(self):
        """Read roles from the file.

        :return: The roles file data.
        """
        return RoleManager.parse_roles_file(path.join(self._location, RoleManager.get_roles_file(self._location)))

    def write_roles(self, users_roles):
        """Write roles to the file. The type of the roles file can be: TXT, XML, JSON.

        :param users_roles: A :py:class:User object's roles defined by the :py:class:Roles object.
        :return:
        """
        roles_file = path.join(self._location, RoleManager.get_roles_file(self._location))
        if roles_file.endswith('txt'):
            with open(roles_file, 'w') as file_obj:
                for id_key, roles_value in users_roles.iteritems():
                    roles_str = ''
                    for role in roles_value:
                        roles_str += '{},'.format(role)
                    file_obj.write('{}: {}\n'.format(id_key, roles_str[:-1]))

        elif roles_file.endswith('json'):
            existing_users_roles = self.read_roles()
            with open(roles_file, 'w') as file_obj:
                existing_users_roles.update(users_roles)
                serializable_existing_users_roles = dict()
                for id_key, roles_value in existing_users_roles.iteritems():
                    serializable_roles = []
                    for role_obj in roles_value:
                        serializable_roles.append(role_obj.role)
                    serializable_existing_users_roles[id_key] = serializable_roles
                dump(serializable_existing_users_roles, file_obj)

        elif roles_file.endswith('xml'):
            existing_users_roles = self.read_roles()
            existing_users_roles.update(users_roles)
            root = ET.Element('users')
            for id_key, roles_value in existing_users_roles.iteritems():
                user = ET.SubElement(root, 'user')
                user.set('id', str(id_key))
                for role in roles_value:
                    role_element = ET.SubElement(user, 'role')
                    role_element.text = role
            tree = ET.ElementTree(root)
            tree.write(roles_file)

    @classmethod
    def get_roles_file(cls, folder_path):
        """
        Determines the path and the file name of the roles file added to a :py:class:Repository object.

        :param folder_path: The path of the :py:class:Repository object.
        :return: The path and the file name of the roles file concatenated.
        """
        number_of_role_files = 0
        for file in listdir(folder_path):
            if file.startswith('roles'):
                if number_of_role_files > 0:
                    raise RuntimeError("Multiple roles file in the repository!")
                elif file.split('.')[1] not in ['txt', 'json', 'xml']:
                    raise TypeError(
                        "Inappropriate file extinsion of {} file, it should be TXT, JSON or XML!".format(
                            file))
                else:
                    return file

    @classmethod
    def parse_roles_file(cls, roles_file):
        """
        Reds the data in the roles file linked to a :py:class:Repository object.

        :param roles_file: The path and the name of the roles file.
        :exception WrongFileTypeError is raised if the roles file type is not TXT, XML or JSON.
        :return: A dictionary that contains the datam the key is a :py:class:User ID and the value is a list of the
        roles linked to the :py:class:User ID.
        """
        with open(roles_file) as file_obj:
            if file_obj.readline() == '':
                return dict()
        if roles_file.endswith('txt'):
            with open(roles_file) as file_obj:
                users_roles = dict()
                for line in file_obj:
                    row = line.split(':')
                    user_id = int(row[0].strip())
                    raw_roles = row[1].strip().split(',')
                    user_roles = []
                    for role in raw_roles:
                        user_roles.append(Role(role.strip()))
                    users_roles[user_id] = user_roles
            return users_roles

        elif roles_file.endswith('json'):
            users_roles = dict()
            with open(roles_file) as file_obj:
                data = load(file_obj)
            for id_key, roles_value in data.iteritems():
                user_roles = []
                for r in roles_value:
                    user_roles.append(Role(r))
                users_roles[int(id_key)] = user_roles
            return users_roles

        elif roles_file.endswith('xml'):
            tree = ET.parse(roles_file)
            users_root = tree.getroot()
            users_roles = dict()
            for user in users_root:
                user_id = int(user.attrib['id'])
                user_roles = []
                for role in user:
                    user_roles.append(Role(role.text))
                users_roles[user_id] = user_roles
            return users_roles

        else:
            raise WrongFileTypeError(
                "The {} file's type is inappropriate it should be TXT, JSON or XML!".format(roles_file))


class UserManager(object):
    """
    Manage user objects.

    The :py:class:UserManager object is defined by paths file, repository location and a location of the :py:class:User
    objects.
    """

    def __init__(self, repository_location, paths_file):
        """
        Initialisation of a new :py:class:UserManager object.

        :param repository_location: The path of the linked to :py:class:Repository object.
        :param paths_file: The paths file of the :py:class:Repository object.
        """
        self.paths_file = paths_file
        self.repository_location = repository_location
        metadata_data = read_ini_file(self.paths_file)
        self._location = path.join(self.repository_location, metadata_data['directories']['users'])

    def save_user(self, user_id, user):
        """Save user to file.

        :param user_id: :py:class:User object's ID.
        :param user: :py:class:User object.
        :return:
        """
        with open(path.join(self._location, str(user_id)), 'w') as user_file:
            user_file.write(user.first_name + '\n')
            user_file.write(user.family_name + '\n')
            user_file.write(str(user.birth) + '\n')
            user_file.write(user.email + '\n')
            user_file.write(''.join(user.password) + '\n')

    def load_user(self, user_id):
        """Load user from file.

        :param user_id: :py:class:User object's ID.
        :return: :py:class:User object.
        """
        with open(path.join(self._location, str(user_id))) as user_file:
            first_name = user_file.readline().rstrip('\n')
            family_name = user_file.readline().rstrip('\n')
            birth = datetime.strptime(user_file.readline().rstrip('\n'), "%Y-%m-%d").date()
            email = user_file.readline().rstrip('\n')
            password = user_file.readline().rstrip('\n')
        user = User(first_name, family_name, birth, email, password)
        return user

    def add_user(self, user):
        """
        Add user to the :py:class:UserManager object and saves it to the filesystem.

        :param user: :py:class:User object
        :return: :py:class:User object's ID.
        """
        user_id = storage_utils.get_next_id(self._location)
        self.save_user(user_id, user)
        return user_id

    def update_user(self, user_id, user):
        """
        Updates a :py:class:User object in the filesystem.

        :param user_id: :py:class:User object's ID
        :param user: :py:class:User object.
        :return:
        """
        self.remove_user(user_id)
        self.save_user(user_id, user)

    def remove_user(self, user_id):
        """
        Remove a :py:class:User object form the :py:class:UserManager object and from the filesystem.

        :param user_id: :py:class:User object's ID.
        :exception ValueError is raised if :py:class:User object with the ``user_id`` ID doesn't exists.
        :return:
        """
        user_file_path = path.join(self._location, str(user_id))
        if path.exists(user_file_path):
            remove(user_file_path)
        else:
            raise ValueError('The user id {} does not exist!'.format(user_id))

    def find_user_by_id(self, user_id):
        """
        Find :py:class:User object by ID.

        :param user_id: :py:class:User object's ID.
        :exception ValueError is raised if :py:class:User object with the ``user_id`` ID doesn't exists.
        :return: :py:class:User object.
        """
        user_file_path = path.join(self._location, str(user_id))
        if path.exists(user_file_path):
            user = self.load_user(user_id)
            return user
        else:
            raise ValueError('The user id {} does not exist!'.format(user_id))

    def find_users_by_name(self, name):
        """
        Find :py:class:User objects by name, the name is the concatenation of :py:attr:first_name and
        :py:attr:family_name.

        :param name: A string to search for in the :py:attr:first_name and :py:attr:family_name.
        :return: :py:class:User objects in a list.
        """
        all_files = UserManager.all_files_in_folder(self._location)
        found_users = []
        for user_file in all_files:
            with open(path.join(self._location, user_file)) as file_obj:
                first_name = file_obj.readline().strip()
                family_name = file_obj.readline().strip()
                if name.lower() in '{} {}'.format(first_name.lower(), family_name.lower()):
                    found_users.append(user_file)
        return found_users

    def find_users_by_email(self, email):
        """
        Find :py:class:User objects by email address.

        :param email: The email address to search for.
        :return: :py:class:User objects in a list.
        """
        all_files = UserManager.all_files_in_folder(self._location)
        found_users = []
        for user_file in all_files:
            with open(path.join(self._location, user_file)) as file_obj:
                for i, line in enumerate(file_obj):
                    if i + 1 == 4 and email.lower() in line.strip().lower():
                        found_users.append(user_file)
        return found_users

    def find_users_by_role(self, role):
        """
        Find :py:class:User objects by role.

        :param role: Role string.
        :return: :py:class:User objects in a list.
        """
        role_manager = RoleManager(self.repository_location, self.paths_file)
        users_roles = role_manager.read_roles()
        found_users = []
        role = Role(role).role
        for id_key, roles_value in users_roles.iteritems():
            for role_obj in roles_value:
                if role == role_obj.role:
                    found_users.append(self.find_user_by_id(id_key))
        return found_users

    def add_role(self, user_id, role):
        """
        Add role to a :py:class:User object.

        :param user_id: :py:class:User object's ID.
        :param role: Role string to add to the :py:class:User object.
        :return:
        """
        role = Role(role)
        _ = self.find_user_by_id(user_id)
        role_manager = RoleManager(self.repository_location, self.paths_file)
        users_roles = role_manager.read_roles()
        if user_id not in users_roles:
            users_roles[user_id] = [role]
        else:
            if role not in users_roles[user_id]:
                users_roles[user_id].append(role)
        role_manager.write_roles(users_roles)

    def remove_role(self, user_id, role):
        """
        Remove role from a :py:class:User object.

        :param user_id: :py:class:User object's ID.
        :param role: Role string to remove from the :py:class:User object.
        :return:
        """
        role_manager = RoleManager(self.repository_location, self.paths_file)
        users_roles = role_manager.read_roles()
        _ = self.find_user_by_id(user_id)
        if user_id not in users_roles:
            raise RuntimeError(
                "The user with {} user ID has no roles, can't remove {} role!".format(user_id, Role(role)))
        else:
            if Role(role) in users_roles[user_id]:
                users_roles[user_id] = users_roles[user_id].remove(Role(role))
            if not users_roles[user_id]:
                users_roles[user_id] = []
        role_manager.write_roles(users_roles)

    def has_role(self, user_id, role):
        """
        Checks if a :py:class:User object has a given role.

        :param user_id: :py:class:User object's ID.
        :param role: Role string to search for within the :py:class:User object.
        :return: Bool, TRUE if the :py:class:User object has a ``role``.
        """
        role_manager = RoleManager(self.repository_location, self.paths_file)
        users_roles = role_manager.read_roles()
        if user_id not in users_roles:
            raise RuntimeError("No user with {} ID!".format(user_id))
        else:
            return Role(role) in users_roles[user_id]

    def list_users_by_role(self):
        """
        Lists :py:class:User objects by role.

        :return: A dictionary whithin the key of the distinct roles and the value of the :py:class:User objects ID in a
        list.
        """
        role_manager = RoleManager(self.repository_location, self.paths_file)
        users_roles = role_manager.read_roles()
        users_by_roles = dict()
        for id_key, roles_values in users_roles.iteritems():
            for role in roles_values:
                if role.role in users_by_roles:
                    users_by_roles[role.role].append(id_key)
                else:
                    users_by_roles[role.role] = [id_key]
        return users_by_roles

    def check_role_file(self, roles_file = None):
        """
        Checks the role file for any errors in the content of the file. The role file type can be TXT, XML and JSON.

        :param roles_file: The path of the role file.
        :return: Bool, TRUE if no errors was found in the content of the file.
        """
        role_manager = RoleManager(self.repository_location, self.paths_file)
        user_roles = role_manager.read_roles()
        if not roles_file:
            roles_file = path.join(self._location, RoleManager.get_roles_file(self._location))
        if RoleManager.get_roles_file(self._location).endswith('txt'):
            with open(roles_file) as file_obj:
                user_ids = []
                for i, line in enumerate(file_obj):
                    if line.split(DELIMITER_CHAR)[0] == '':
                        raise ValueError("In the role file's {}th line has no user identifier!".format(i + 1))
                    elif DELIMITER_CHAR not in line or line.count(DELIMITER_CHAR) > 1:
                        raise ValueError(
                            "Missing or too many '{}' character in the {}th line!".format(DELIMITER_CHAR, i + 1))

                    roles = []
                    for role in line.split(DELIMITER_CHAR)[1].split(ROLE_DELIMITER_CHAR):
                        roles.append(role.strip())
                    roles_count = Counter(roles)
                    for key, value in roles_count.iteritems():
                        if value > 1:
                            raise ValueError("The {} role is duplicated in the {}th line!".format(key, i + 1))
                    for role in roles:
                        role = role.strip()
                        if role.isspace() or role == '':
                            raise ValueError(
                                "Too many '{}' characters in the {}th line!".format(ROLE_DELIMITER_CHAR, i + 1))
                        Role(role)

                    user_ids.append(line.split(DELIMITER_CHAR)[0])
                user_ids_counter = Counter(user_ids)
                for key, value in user_ids_counter.iteritems():
                    if value > 1:
                        raise ValueError("The {} user id is duplicated!".format(key))
            return True


        elif RoleManager.get_roles_file(self._location).endswith('json'):
            with open(roles_file) as file_obj:
                data = load(file_obj)
            for id_key, roles_value in data.iteritems():
                if not isinstance(id_key, unicode):
                    raise MissingUserIdentifierError(
                        "In the role file has no user identifier!")
                else:
                    try:
                        int(id_key)
                    except ValueError:
                        MissingUserIdentifierError(
                            "In the role file the {} key should be a number!".format(
                                id_key))
                if not isinstance(roles_value, list):
                    raise InvalidRoleNameError(
                        "The roles should be stored in a list, not in a {}!".format(
                            type(roles_value).__name__))
                else:
                    for role in roles_value:
                        try:
                            Role(role)
                        except ValueError:
                            raise InvalidRoleNameError(
                                "The {} role name is invalid!".format(role))
                    roles_count = Counter(roles_value)
                    for key, value in roles_count.iteritems():
                        if value > 1:
                            raise DuplicatedRolesError(
                                "The {} role is duplicated!".format(key))
            return True

        elif RoleManager.get_roles_file(self._location).endswith('xml'):
            tree = ET.parse(roles_file)
            users_root = tree.getroot()
            users_list = []
            if users_root.tag != 'users':
                raise MissingUserIdentifierError(
                    "In the role file the root tag must be 'users' not {}!".format(
                        users_root.tag))
            for user in users_root:
                if user.tag != 'user':
                    raise MissingUserIdentifierError(
                        "In the role file the root's child tags must be 'user' not {}!".format(
                            user.tag))
                try:
                    users_list.append(int(user.attrib['id']))
                except KeyError:
                    raise MissingUserIdentifierError("The user tag must have an 'id' attribute!")
                except ValueError:
                    raise MissingUserIdentifierError(
                        "The user tag must have an 'id' attribute which is a number, not a {}!".format(
                            type(user.attrib['id']).__name__))
                user_roles = []
                for role in user:
                    try:
                        user_roles.append(Role(role.text))
                    except ValueError:
                        raise InvalidRoleNameError("The {} role name is invalid!".format(role))
                roles_count = Counter(user_roles)
                for key, value in roles_count.iteritems():
                    if value > 1:
                        raise DuplicatedRolesError("The {} role is duplicated!".format(key))
            users_list = Counter(user_roles)
            for key, value in users_list.iteritems():
                if value > 1:
                    raise DuplicatedRolesError("The {} user ID is duplicated!".format(key))
        else:
            raise WrongFileTypeError("The roles file's type is inappropriate it should be TXT, JSON or XML!")

    @classmethod
    def all_files_in_folder(cls, file_path, file_format = ''):
        """
        Searches for all the :py:class:User objects representation in the filesystem.

        :param file_path: The path of the users directory.
        :param file_format: The format of the :py:class:User objects file representation.
        :return: A list of the files names with :py:class:User object data in it.
        """
        files_and_folders = listdir(file_path)
        all_files = []
        for item in files_and_folders:
            if path.isfile(path.join(file_path, item)) and item.split('.')[0] != 'roles':
                if len(file_format) != 0:
                    if item.endswith(file_format):
                        all_files.append(item)
                else:
                    all_files.append(item)
        return all_files

    def find_all_users(self):
        """
        Finds all available :py:class:User objects IDs.

        :return: A list of the available :py:class:User object IDs.
        """
        all_available_users = []
        for file_or_folder in listdir(self._location):
            if path.isfile(path.join(self._location, file_or_folder)):
                try:
                    all_available_users.append(int(file_or_folder))
                except:
                    pass
        return all_available_users

    def count_users(self):
        """
        Counts the :py:class:User objects.

        :return: Integer.
        """
        return len(self.find_all_users())

    def set_role_file(self, new_row_file_path):
        """
        Moves the role file to a new path.

        :param new_row_file_path: The path to were to move the roles file.
        :exception TypeError is raised if the new path doesn't exists.
        :return:
        """
        if path.exists(path.dirname(new_row_file_path)):
            role_file = path.join(self._location, RoleManager.get_roles_file(self._location))
            move(role_file, new_row_file_path)
            self._location = path.dirname(new_row_file_path)
        else:
            raise TypeError("The {} path doesn't exists!".format(path.dirname(new_row_file_path)))
